# param.nnet.results function read and combined results of typically given by
# param.nnet.trainNtest function

# resultDirPath = path directory where all files generated by param.nnet.trainNtest are (and only them!)
# data = database for the species in data.frame format (if variable selection is required, it has to be done before)

param.nnet.results <- function(resultDirPath, data){


#------------------------------ Initialization -----------------------------#
	# List all files in the given directory
	list <- list.files(resultDirPath)
	B <- length(list)
	n <- 100

	# Redo database so that response variable is factor
	n1 <- ncol(data)
	dat <- cbind(data[,1:(n1-1)],as.factor(data[,n1]))
	colnames(dat)[n1] <- "pred"
	# Keep response variable not in a factor format
	y <- dat[,n1]	

	# Create storage matrix for all resubstitution and bootstrap errors & for all bootstraps
	error <- NULL
	for(i in 1:(n)){error <- cbind(error,rbind(matrix(NA,B,2),matrix(NA,3,2)))}
	colnames(error) <- rep(c("Resub.","BOOT"),n)
	rownames(error) <- c(paste("B",1:B,sep=""),"Mean",".632 error",".632+ error")

	# Tree structure of previous matrix using list ; each node/level represents a parameter
	err <- list(rep(list(rep(list(rep(list(error),length(d))),length(m))),length(s)))

	# Parameters of NNET
	s <- 2:5
	m <- c(500,750,1000,1250,1500)
	d <- c(0.01,0.001,0.0001)


	# Create storage matrix of all .632+ error
	best <- matrix(NA,(length(s)*length(m)*length(d)),4)
	rownames(best) <- paste("model ",1:(length(s)*length(m)*length(d)),sep="")
	colnames(best) <- c("Size","Maxiter","Decay",".632+")

#----------------------------------- Body ----------------------------------#
	# Read and store all results
	for(b in 1:B){
		cat("File ",b,"\n")

		# Read result
		res <- as.matrix(read.table(list[b],header=T))

		# Counter
		cpt <- 1

		# Loops, one for each parameter
		for(i in 1:length(s)){
			for(j in 1:length(m)){
				for(k in 1:length(d)){
					err[[1]][[i]][[j]][[k]][b,] <- res[cpt,4:203]
					cpt <- cpt + 1
				}
			}
		}
	}

	# Re-initialize counter
	cpt <- 1

	# Required function
	f <- function(x) mean(x, na.rm=T)

	# Loops, one for each parameter
	for(i in 1:length(s)){
		for(j in 1:length(m)){
			for(k in 1:length(d)){
				# Compute the underestimated resubstitution error and
				# the overestimated BOOT error
				err[[1]][[i]][[j]][[k]][(B+1),] <- apply(err[[1]][[i]][[j]][[k]][1:B,],2,f)

				l <- 1
				while(l<(2*n)){

					# Compute .632 estimate for a given model and all its repetitions
					err[[1]][[i]][[j]][[k]][(B+2),l] <- sum(err[[1]][[i]][[j]][[k]][(B+1),l:(l+1)]*c(0.368,0.632))

					# Train model on all data
					model <- nnet(pred~.,data=dat, trace=F, size=s[i], maxit=m[j], decay=d[k])
					model.pred.all <- as.numeric(predict(model,newdata=dat, type="class"))

					# Compute gamma, no information rate, and weights for a given model and all its repetitions
					gamma <- (sum(data[,n1])*sum(model.pred.all))/length(data[,n1])+
							(sum(1-data[,n1])*sum(1-model.pred.all))/length(data[,n1])
					NIR <- (err[[1]][[i]][[j]][[k]][(B+1),(l+1)] - err[[1]][[i]][[j]][[k]][(B+1),l])/
						(gamma - err[[1]][[i]][[j]][[k]][(B+1),l])
					w <- 0.632/(1-0.368*NIR)

					# Compute .632+ estimate
					err[[1]][[i]][[j]][[k]][(B+3),l] <- w*err[[1]][[i]][[j]][[k]][(B+1),(l+1)] + 
											(1 - w)*err[[1]][[i]][[j]][[k]][(B+1),l]
					l <- l + 2
				}

				# Store the estimated .632+ error (average overall repetitions)
				best[cpt,4] <- mean(err[[1]][[i]][[j]][[k]][(B+3),], na.rm=T)
				best[cpt,1:3] <- c(s[i],m[j],d[k])
				cat("cpt=",cpt,"\n")
				cpt <- cpt + 1
			}
		}
	}

#---------------------------------- Output ---------------------------------#
	output <- NULL
	out <- best[best[,4]==min(best[,4]),]
	ifelse(is.matrix(out),NA,out<-t(as.matrix(out)))
	rownames(out) <- ifelse(nrow(out)==1,"Best model",paste("Best model ",1:nrow(out),sep=""))
	output$best.models <- out
	output$all.models <- best
	output$supplement <- err[[1]][[1]][[1]][[1]]
	capture.output(output,file=paste(species.name,"_param.nnet.boot.all.txt",sep=""), append=FALSE)
	return(output)
}

